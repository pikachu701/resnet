# 定义 Sobel 过滤器（用于计算边缘）
sobel_x = torch.tensor([[1, 0, -1], [2, 0, -2], [1, 0, -1]], dtype=torch.float32).view(1, 1, 3, 3)
sobel_y = torch.tensor([[1, 2, 1], [0, 0, 0], [-1, -2, -1]], dtype=torch.float32).view(1, 1, 3, 3)

# 计算边缘
def edge_loss(pred, target):
    """计算预测和真实目标的 Sobel 边缘差异"""
    device = pred.device  # 确保 Sobel 过滤器在相同设备上
    sobel_x_dev = sobel_x.to(device)
    sobel_y_dev = sobel_y.to(device)

    # 计算边缘（Sobel 过滤器提取 X 和 Y 方向的边缘）
    edge_pred_x = F.conv2d(pred, sobel_x_dev, padding=1)
    edge_pred_y = F.conv2d(pred, sobel_y_dev, padding=1)
    edge_pred = torch.sqrt(edge_pred_x ** 2 + edge_pred_y ** 2 + 1e-6)

    edge_target_x = F.conv2d(target, sobel_x_dev, padding=1)
    edge_target_y = F.conv2d(target, sobel_y_dev, padding=1)
    edge_target = torch.sqrt(edge_target_x ** 2 + edge_target_y ** 2 + 1e-6)

    return F.l1_loss(edge_pred, edge_target)

# 定义最终的损失函数
class EdgeAwareLoss(nn.Module):
    def __init__(self, alpha=0.5):
        """alpha 控制 MSE 和 Edge Loss 的权重"""
        super(EdgeAwareLoss, self).__init__()
        self.mse = nn.MSELoss()
        self.alpha = alpha  # alpha = 0.5 表示 50% 关注边缘，50% 关注像素误差

    def forward(self, pred, target):
        mse_loss = self.mse(pred, target)
        edge_loss_value = edge_loss(pred, target)
        total_loss = mse_loss + self.alpha * edge_loss_value  # 结合两种损失
        return total_loss

# 使用新损失函数
criterion = EdgeAwareLoss(alpha=0.5)
loss = criterion(outputs, images_perfect)
